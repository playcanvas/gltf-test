<!DOCTYPE html>
<html>
<head>
    <title>Gltf Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/png" href="../playcanvas-favicon.png" />
    <script src="playcanvas.js"></script>
    <script src="draco/draco.wasm.js"></script>
    <style>
        body { 
            margin: 0;
            overflow-y: hidden;
        }
    </style>
</head>

<body>
    <!-- The canvas element -->
    <canvas id="application-canvas"></canvas>

    <!-- The script -->
    <script>

        // get a browser string
        // taken from https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
        const browser = (() => {
            // firefox
            if (typeof InstallTrigger !== 'undefined') {
                return 'firefox'
            }

            // safari
            if (/constructor/i.test(window.HTMLElement) ||
                (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] ||
                (typeof safari !== 'undefined' && window['safari'].pushNotification))) {
                return 'safari';
            }

            // chrome
            return !!window.chrome ? 'chrome' : 'unknown';
        })();

        const run = (modelIndex) => {
            // load and initialize draco
            const canvas = document.getElementById("application-canvas");

            // create the app and start the update loop
            const app = new pc.Application(canvas);
            const device = app.graphicsDevice;

            // fix canvas resolution
            app.setCanvasResolution(pc.RESOLUTION_FIXED, 800, 600);

            // create the camera
            const camera = new pc.Entity();
            camera.addComponent("camera", {
                clearColor: new pc.Color(0.4, 0.45, 0.5)
            });
            app.root.addChild(camera);

            // create the entity
            const light = new pc.Entity();
            light.addComponent("light", {
                type: "directional",
                color: new pc.Color(1, 1, 1),
                range: 100,
                castShadows: true,
                shadowBias: 0.2,
                shadowDistance: 5,
                normalOffsetBias: 0.05,
                shadowResolution: 2048
            });
            light.setLocalEulerAngles(45, 30, 0);
            app.root.addChild(light);
            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);

            const update = (ms) => {
                pc.ComponentSystem.update(ms, false);
                pc.ComponentSystem.animationUpdate(ms, false);
                pc.ComponentSystem.postUpdate(ms, false);
            };

            const render = () => {
                app.batcher.updateAll();
                app.renderer.renderComposition(app.scene.layers);
            };

            const placeCamera = (camera, meshInstances) => {
                const bbox = new pc.BoundingBox();
                meshInstances.forEach((mi, i) => {
                    bbox[i === 0 ? 'copy' : 'add'](mi.aabb);
                });

                const bboxMax = bbox.getMax();
                const distance = (bbox.halfExtents.length() * 1.4) / Math.sin(0.5 * camera.camera.fov * camera.camera.aspectRatio * pc.math.DEG_TO_RAD);
                camera.setPosition(bboxMax.x, bboxMax.y, bbox.center.z + distance);
                camera.lookAt(bbox.center);
                camera.camera.nearClip = distance / 10;
                camera.camera.farClip = distance * 10;

                light.light.shadowDistance = distance * 2;
            };

            const dataURItoBlob = function(dataURI) {
                var byteString = atob(dataURI.split(',')[1]);
                var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                var ab = new ArrayBuffer(byteString.length);
                var dw = new DataView(ab);
                for(var i = 0; i < byteString.length; i++) {
                    dw.setUint8(i, byteString.charCodeAt(i));
                }
                return new Blob([ab], {type: mimeString});
            }

            const upload = (test, platform) => {
                const blob = dataURItoBlob(canvas.toDataURL());

                const formData = new FormData();
                formData.append('pngimage', blob);
                formData.append('test', test);
                formData.append('platform', platform);

                fetch("upload", {
                    method: "POST",
                    body: formData,
                })
                .then((response) => { });
            };

            // iterate over all models and variants
            let mindex = 0;
            let vindex = 0;
            const renderNext = () => {
                if (mindex === modelIndex.length) {
                    // finished
                    const doneDiv = document.createElement('div');
                    doneDiv.id = 'visual-regression-complete';
                    document.body.appendChild(doneDiv);
                } else {
                    const model = modelIndex[mindex];
                    const vkeys = Object.keys(model.variants);
                    const variant = vkeys[vindex];
                    const url = `${model.name}/${variant}/${model.variants[variant]}`;

                    app.assets.loadFromUrl(url, "container", function (err, asset) {
                        if (err) {
                            console.log(`error loading model err=${err}`);
                        } else {
                            // add the entity to the scene
                            const entity = new pc.Entity();
                            entity.addComponent("model", {
                                type: "asset",
                                asset: asset.resource.model,
                                castShadows: true
                            });
                            app.root.addChild(entity);

                            // frame 0
                            update(1.0 / 60.0);
                            render();

                            // frame 1
                            placeCamera(camera, entity?.model?.meshInstances || []);
                            update();
                            render();

                            // update
                            upload(`${model.name}/${variant}`, browser);

                            // clean up
                            app.root.removeChild(entity);
                            entity.destroy();

                            app.assets.remove(asset);
                            asset.unload();
                        }

                        if (++vindex === vkeys.length) {
                            vindex = 0;
                            ++mindex;
                        }

                        renderNext();
                    });
                }
            }

            renderNext();
        }

        // load and initialize draco
        const moduleName = 'DracoDecoderModule';
        window[moduleName]({
            locateFile: () => 'draco/draco.wasm.wasm'
        }).then((instance) => {
            window[moduleName] = instance;

            // load the list of gltf models
            fetch('model-index.json')
                .then((response) => response.json())
                .then((json) => {
                    // finally, run the application
                    run(json);
                });
        });
    </script>
</body>
</html>
